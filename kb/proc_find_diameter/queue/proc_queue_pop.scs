// Удаление первого элемента очереди
// Возвращает значение удаляемого элемента

scp_program -> proc_queue_pop (*
	-> rrel_params: ... (*
		->rrel_1: rrel_in: _queue_head;; 
		->rrel_2: rrel_in: _queue_tail;;

		->rrel_3: rrel_out: _element_value;;
	*);;
	
	-> rrel_operators: ... (*

		// Проверяем, является ли очередь пустой
		-> rrel_init: ..proc_queue_pop_queue_is_empty (*
			<- searchElStr3;;
		 	-> rrel_1: rrel_fixed: rrel_scp_var: rrel_node: _queue_head;;
			-> rrel_2: rrel_assign: rrel_scp_var: rrel_pos_const_perm: _arc2;;
			-> rrel_3: rrel_assign: rrel_scp_var: rrel_node: _queue_first_element;;


		 	=> nrel_then: ..proc_queue_pop_erase_head;; // если очередь не пустая
		 	=> nrel_else: ..proc_queue_pop_return;; // если очередь пустая
		*);;

		// Удаление связи между указателем на начало очереди и первым элементом
		-> ..proc_queue_pop_erase_head (*
			<- eraseEl;;
			-> rrel_1: rrel_fixed: rrel_scp_var: rrel_erase: _arc2;;

			=> nrel_goto: ..proc_queue_pop_find_second_element;;
		*);;

		// Находим второй элемент очереди
		-> ..proc_queue_pop_find_second_element (*
			<- searchElStr5;;
		 	-> rrel_1: rrel_fixed: rrel_scp_var: rrel_node: _queue_first_element;;
			-> rrel_2: rrel_assign: rrel_scp_var: rrel_pos_const_perm: _arc2;;
			-> rrel_3: rrel_assign: rrel_scp_var: rrel_node: _queue_second_element;;
			-> rrel_4: rrel_assign: rrel_scp_var: rrel_pos_const_perm: _arc4;;
			-> rrel_5: rrel_fixed: rrel_scp_const: rrel_queue_next;;

		 	=> nrel_then: ..proc_queue_pop_erase_elements_connection;; // если в очереди несколько элементов
		 	=> nrel_else: ..proc_queue_pop_find_tail;; // если очередь состоит из одного элемента
		*);;

		// Удаление связи между вторым и первым элементами
		-> ..proc_queue_pop_erase_elements_connection (*
			<- eraseElStr5;;
			-> rrel_1: rrel_fixed: rrel_scp_var: rrel_node: _queue_first_element;;
			-> rrel_2: rrel_assign: rrel_scp_var: rrel_pos_const_perm: rrel_erase: _arc2;;
			-> rrel_3: rrel_fixed: rrel_scp_var: rrel_node: _queue_second_element;;
			-> rrel_4: rrel_assign: rrel_scp_var: rrel_pos_const_perm: rrel_erase: _arc4;;
			-> rrel_5: rrel_fixed: rrel_scp_const: rrel_queue_next;;

			=> nrel_goto: ..proc_queue_pop_new_head;;
		*);;

		// Установка начала очереди на второй элемент
		-> ..proc_queue_pop_new_head (*
			<- genElStr3;;
			-> rrel_1: rrel_fixed: rrel_scp_var: rrel_node: _queue_head;;
			-> rrel_2: rrel_assign: rrel_scp_var: rrel_pos_const_perm: _arc2;;
			-> rrel_3: rrel_fixed: rrel_scp_var: rrel_node: _queue_second_element;;

			=> nrel_goto: ..proc_queue_pop_find_element_value;;
		*);;

		/*// Поиск дуги между указателем на конец очереди и единственным элементом
		-> ..proc_queue_pop_find_tail (*
			<- searchElStr3;;
			-> rrel_1: rrel_fixed: rrel_scp_var: rrel_node: _queue_tail;;
			-> rrel_2: rrel_assign: rrel_scp_var: rrel_pos_const_perm: _arc2;;
			-> rrel_3: rrel_assign: rrel_scp_var: rrel_node: _last_element;;

			=> nrel_then: ..proc_queue_pop_delete_tail;;
			=> nrel_else: ..proc_queue_pop_find_element_value;;
		*);;

		// Удаление связи между указателем на конец очереди и единственным элементом
		-> ..proc_queue_pop_delete_tail (*
			<- eraseEl;;
			-> rrel_1: rrel_fixed: rrel_scp_var: rrel_erase: _arc2;;

			=> nrel_goto: ..proc_queue_pop_find_element_value;;
		*);;*/

		-> ..proc_queue_pop_find_tail (*
			<- eraseSetStr3;;
			-> rrel_1: rrel_fixed: rrel_scp_var: rrel_node: _queue_tail;;
			-> rrel_2: rrel_assign: rrel_scp_var: rrel_pos_const_perm: rrel_erase: _arc2;;
			-> rrel_3: rrel_assign: rrel_scp_var: rrel_node: _last_element;;

			=> nrel_goto: ..proc_queue_pop_find_element_value;;
		*);;

		// Поиск значения элемента очереди
		-> ..proc_queue_pop_find_element_value (*
			<- searchElStr5;;
			-> rrel_1: rrel_fixed: rrel_scp_var: rrel_node: _queue_first_element;;
			-> rrel_2: rrel_assign: rrel_scp_var: rrel_pos_const_perm: _arc2;;
			-> rrel_3: rrel_assign: rrel_scp_var: rrel_node: _element_value;;
			-> rrel_4: rrel_assign: rrel_scp_var: rrel_pos_const_perm: _arc4;;
			-> rrel_5: rrel_fixed: rrel_scp_const: rrel_queue_value;;

			=> nrel_goto: ..proc_queue_pop_delete_element;;
		*);;

		// Удаление самого элемента очереди
		-> ..proc_queue_pop_delete_element (*
			<- eraseElStr5;;
			-> rrel_1: rrel_fixed: rrel_scp_var: rrel_node: _queue_first_element;;
			-> rrel_2: rrel_assign: rrel_scp_var: rrel_pos_const_perm: rrel_erase: _arc2;;
			-> rrel_3: rrel_fixed: rrel_scp_var: rrel_node: _element_value;;
			-> rrel_4: rrel_assign: rrel_scp_var: rrel_pos_const_perm: rrel_erase: _arc4;;
			-> rrel_5: rrel_fixed: rrel_scp_const: rrel_queue_value;;

			=> nrel_goto: ..proc_queue_pop_print;;
		*);;
		
// Проверяет, вернет ли процедура какое-нибудь значение
/*
		-> ..proc_queue_pop_check_value (*
			<- ifVarAssign;;
			-> rrel_1: rrel_fixed: rrel_scp_var: _element_value;;

			=> nrel_then: ..proc_queue_pop_value_yes;;
			=> nrel_else: ..proc_queue_pop_value_no;;
		*);;

		-> ..proc_queue_pop_operator_value_yes (*
			<- printNl;;
			-> rrel_1: rrel_fixed: rrel_scp_const: [Popping performed successful!];;

			=> nrel_goto: ..proc_queue_pop_operator_return;;
		*);;

		-> ..proc_queue_pop_operator_value_no (*
			<- printNl;;
			-> rrel_1: rrel_fixed: rrel_scp_const: [Popping has failed!];;

			=> nrel_goto: ..proc_queue_pop_operator_return;;
		*);;
*/

// Вывод значения удаляемого элемента
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		
		-> ..proc_queue_pop_print (*
			<- print;;
			-> rrel_1: rrel_fixed: rrel_scp_const: [Element popped from queue: ];;

			=> nrel_goto: ..proc_queue_pop_print_idtf;;
		*);;

		-> ..proc_queue_pop_print_idtf (*
			<- call;;
			-> rrel_1: rrel_fixed: rrel_scp_const: proc_print_idtf;;
			-> rrel_2: rrel_fixed: rrel_scp_const: ... (*
				-> rrel_1: rrel_fixed: rrel_scp_var: _element_value;;
			*);;
			-> rrel_3: rrel_assign: rrel_scp_var: _descr;;

			=> nrel_goto: ..proc_queue_pop_print_idtf_return;;
		*);;

		-> ..proc_queue_pop_print_idtf_return (*
			<- waitReturn;;
			-> rrel_1: rrel_fixed: rrel_scp_var: _descr;;

			=> nrel_goto: ..proc_queue_pop_print_delimiter;;
		*);;

		-> ..proc_queue_pop_print_delimiter (*
			<- printNl;;
			-> rrel_1: rrel_fixed: rrel_scp_const: [;];;

			=> nrel_goto: ..proc_queue_pop_return;;
		*);;
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

		-> ..proc_queue_pop_return (*
			<- return;;
		*);;	
	*);;
*);;
